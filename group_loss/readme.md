## Пояснение полей:
- **type**: 
  - `global` - применяет норму ко всем параметрам сети
  - `layerwise` - применяет норму к каждому слою/группе отдельно
  - `hierarchical` - комбинирует вложенные регуляризаторы
  
- **groups**:
  - `None` - без группировки (для global)
  - `base_level` - группировка по фильтрам/нейронам
  - `layer` - группировка по слоям
  - `blocks` - группировка по архитектурным блокам

- **norm**: `L1` или `L2`

Этот подход позволяет:
1. Комбинировать разные типы регуляризации
2. Строить произвольные иерархии регуляризаторов
3. Легко экспериментировать с разными уровнями группировки
4. Применять разные коэффициенты для разных уровней

## 1. Поля конфигурационного узла

| Поле             | Тип / Значения                                        | Значение по умолчанию | Описание                                                                                                                                                                                                                                                        |
| ---------------- | ----------------------------------------------------- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`type`**       | `"global"` \| `"layerwise"` \| `"hierarchical"`       | —                     | *Единица группировки*.<br>  • **global** — сразу ко всем выбранным параметрам;<br>  • **layerwise** — обход по группам‑детям (слоям, фильтрам …);<br>  • **hierarchical** — **контейнер**: сам штраф не накладывает, а просто передаёт под‑группу в `children`. |
| **`groups`**     | `null` \| `"base_level"` \| `"layer"` \| `"blocks"` … | `null`                | Фильтр по меткам `HierarchicalGroup`. Если `null` — берутся все группы из текущего контекста.                                                                                                                                                                   |
| **`norm`**       | `"sum"` \| `"L1"` \| `"L2"`                           | `"L2"`                | **Внешняя** норма (между группами).<br>  • *sum* — простая сумма;<br>  • *L1* — вызывает sparsity (зануление групп);<br>  • *L2* — weight‑decay между группами.                                                                                                 |
| **`inner_norm`** | `"L1"` | `"L2"` | `"L0"`/`"L0approx"` | `"none"`                          | `"L2"`                | **Внутренняя** норма, рассчитываемая на каждый элемент множества‑группы.<br>  Используется, например, чтобы задать **group‑Lasso**: `inner_norm="L2"`, `norm="L1"`. Значение `"L0"` (синоним `"L0approx"`) считает сумму `|w|^{0.1}` — гладкий аналог количества ненулей. |
| **`lambda`**     | `float ≥ 0`                                           | `0.0`                 | Коэффициент регуляризации для **текущего** узла. Игнорируется, если `type="hierarchical"`.                                                                                                                                                                      |
| **`children`**   | `list[Dict]`                                          | `[]`                  | Под‑узлы. Разрешено только для `type="hierarchical"`.                                                                                                                                                                                                           |

### Операция «inner → outer»

1. Для каждого элемента множества‑группы (фильтр, слой …) считается `inner_norm`.
2. К получившемуся вектору норм применяется `norm`.
3. Результат умножается на `lambda` и суммируется с лоссами дочерних узлов.

---

## 2. Базовые шаблоны

| Сценарий                            | Конфигурация                                      | Что зануляется                  |
| ----------------------------------- | ------------------------------------------------- | ------------------------------- |
| **Классический weight‑decay**       | `norm="L2", inner_norm="L2"`                      | ничего, веса плавно «усыхают»   |
| **L1‑разреживание отдельных весов** | `norm="sum", inner_norm="L1"`                     | отдельные параметры             |
| **Group‑Lasso (фильтр/нейрон)**     | `norm="L1", inner_norm="L2", groups="base_level"` | целые выходные каналы / нейроны |
| **Structured sparsity слоя**        | `norm="L1", inner_norm="L2", groups="layer"`      | весь слой целиком               |

---

## 3. Примеры конфигураций

### 3.1. Global L2‑decay + group‑Lasso по фильтрам

```python
reg_cfg = {
    "type": "hierarchical",      # контейнер
    "children": [
        {   # общий weight‑decay
            "type": "global",
            "norm": "L2",
            "lambda": 0.01
        },
        {   # group‑Lasso в каждом слое
            "type": "layerwise",
            "groups": "base_level",
            "norm": "L1",          # L1 по фильтрам
            "inner_norm": "L2",    # L2 внутри фильтра
            "lambda": 0.002
        }
    ]
}
```

### 3.2. Structured sparsity по слоям

```python
layer_sparsity = {
    "type": "layerwise",
    "groups": "layer",
    "norm": "L1",       # L1 по слоям
    "inner_norm": "L2", # L2 внутри слоя (все веса вместе)
    "lambda": 0.005
}
```

### 3.3. «Плавный» decay фильтров без зануления

```python
smooth_decay_filters = {
    "type": "layerwise",
    "groups": "base_level",
    "norm": "L2",          # L2‑квадрат по фильтрам
    "inner_norm": "L2",    # L2 внутри фильтра
    "lambda": 1e-4
}
```

### 3.4. L0-подобная sparsity по фильтрам

```python
l0_filters = {
    "type": "layerwise",
    "groups": "base_level",
    "norm": "L1",        # L1 по фильтрам
    "inner_norm": "L0",  # ≈L0 внутри фильтра
    "lambda": 0.03
}
```

### 3.5. Сложная иерархия «блок → слой → фильтр»

```python
complex_hierarchy = {
    "type": "hierarchical",
    "groups": "blocks",      # спускаемся в каждый ResNet‑блок
    "children": [
        {
            "type": "layerwise",   # L1 group‑Lasso по слоям блока
            "groups": "layer",
            "norm": "L1",
            "inner_norm": "L2",
            "lambda": 0.01
        },
        {
            "type": "hierarchical", # контейнер для отдел. штрафа на фильтры
            "groups": "layer",
            "children": [
                {
                    "type": "layerwise",   # L2‑decay фильтров
                    "groups": "base_level",
                    "norm": "L2",
                    "inner_norm": "L2",
                    "lambda": 1e-4
                }
            ]
        }
    ]
}
```

---

## 4. Быстрый справочник «что поставить»

| Хотим                              | norm    | inner\_norm               |
| ---------------------------------- | ------- | ------------------------- |
| Обычный L2 weight‑decay            | `"L2"`  | (можно опустить → `"L2"`) |
| L1 sparsity (отдельные веса)       | `"sum"` | `"L1"`                    |
| Group‑Lasso (фильтр/нейрон)        | `"L1"`  | `"L2"`                    |
| L2‑decay по группам (без sparsity) | `"L2"`  | `"L2"`                    |
| L0-подобная sparsity (≈ количество ненулей) | `"L1"`  | `"L0"`                    |

---

## 5. Замечания по реализации

* Узел `hierarchical` **не** применяет штраф — только инициализирует рекурсию.
* Если у узла `lambda == 0`, расчёт пропускается (произведёт 0, но дети считаются).
* По‑умолчанию `inner_norm="L2"`, так что старые конфиги (`norm="L1"`) продолжают работать как group‑Lasso.
